const t=JSON.parse('{"key":"v-16e02b8a","path":"/FrontEnd/JavaScript/DesignPattern/","title":"设计模式","lang":"zh-CN","frontmatter":{"title":"设计模式","icon":"icon-park:graphic-design","article":false,"description":"JavaScript 中的设计模式种类丰富，它们根据功能和目的的不同，可以被分为三大类： 创建型设计模式 构造函数模式 通过定义一个构造函数来初始化新对象的属性，并通过new关键字调用构造函数创建实例。 原型模式 通过复制现有对象来创建新对象，而不是每次都新建一个全新的实例。 工厂模式 提供一个接口用于创建一系列相关或依赖对象，而无需指定具体的类。 抽象工厂模式 提供一个接口，用于创建相关或依赖对象家族的工厂，而无需指定具体的产品类。 建造者模式 将复杂的构建过程与表示分离，使得相同的构建过程可以创建不同的表示。 单例模式 确保一个类只有一个实例，并提供全局访问点。","head":[["meta",{"property":"og:url","content":"https://zequanr.github.io/FrontEnd/JavaScript/DesignPattern/"}],["meta",{"property":"og:site_name","content":"ZEQUANR"}],["meta",{"property":"og:title","content":"设计模式"}],["meta",{"property":"og:description","content":"JavaScript 中的设计模式种类丰富，它们根据功能和目的的不同，可以被分为三大类： 创建型设计模式 构造函数模式 通过定义一个构造函数来初始化新对象的属性，并通过new关键字调用构造函数创建实例。 原型模式 通过复制现有对象来创建新对象，而不是每次都新建一个全新的实例。 工厂模式 提供一个接口用于创建一系列相关或依赖对象，而无需指定具体的类。 抽象工厂模式 提供一个接口，用于创建相关或依赖对象家族的工厂，而无需指定具体的产品类。 建造者模式 将复杂的构建过程与表示分离，使得相同的构建过程可以创建不同的表示。 单例模式 确保一个类只有一个实例，并提供全局访问点。"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-24T08:24:26.000Z"}],["meta",{"property":"article:author","content":"ZEQUANR"}],["meta",{"property":"article:modified_time","content":"2024-01-24T08:24:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"设计模式\\",\\"description\\":\\"JavaScript 中的设计模式种类丰富，它们根据功能和目的的不同，可以被分为三大类： 创建型设计模式 构造函数模式 通过定义一个构造函数来初始化新对象的属性，并通过new关键字调用构造函数创建实例。 原型模式 通过复制现有对象来创建新对象，而不是每次都新建一个全新的实例。 工厂模式 提供一个接口用于创建一系列相关或依赖对象，而无需指定具体的类。 抽象工厂模式 提供一个接口，用于创建相关或依赖对象家族的工厂，而无需指定具体的产品类。 建造者模式 将复杂的构建过程与表示分离，使得相同的构建过程可以创建不同的表示。 单例模式 确保一个类只有一个实例，并提供全局访问点。\\"}"]]},"headers":[{"level":3,"title":"创建型设计模式","slug":"创建型设计模式","link":"#创建型设计模式","children":[]},{"level":3,"title":"结构型设计模式","slug":"结构型设计模式","link":"#结构型设计模式","children":[]},{"level":3,"title":"行为型设计模式","slug":"行为型设计模式","link":"#行为型设计模式","children":[]}],"git":{"createdTime":1706084666000,"updatedTime":1706084666000,"contributors":[{"name":"ZEQUANR","email":"675897584@qq.com","commits":1}]},"readingTime":{"minutes":2.66,"words":797},"filePathRelative":"FrontEnd/JavaScript/DesignPattern/README.md","localizedDate":"2024年1月24日","excerpt":"<p>JavaScript 中的设计模式种类丰富，它们根据功能和目的的不同，可以被分为三大类：</p>\\n<h3> <a href=\\"/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/\\" target=\\"blank\\">创建型设计模式</a></h3>\\n<ul>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/ConstructorPattern\\">构造函数模式</a>\\n<ul>\\n<li>通过定义一个构造函数来初始化新对象的属性，并通过new关键字调用构造函数创建实例。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/PrototypePattern\\">原型模式</a>\\n<ul>\\n<li>通过复制现有对象来创建新对象，而不是每次都新建一个全新的实例。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/FactoryPattern\\">工厂模式</a>\\n<ul>\\n<li>提供一个接口用于创建一系列相关或依赖对象，而无需指定具体的类。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/AbstractFactoryPattern\\">抽象工厂模式</a>\\n<ul>\\n<li>提供一个接口，用于创建相关或依赖对象家族的工厂，而无需指定具体的产品类。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/BuilderPattern\\">建造者模式</a>\\n<ul>\\n<li>将复杂的构建过程与表示分离，使得相同的构建过程可以创建不同的表示。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/SingletonPattern\\">单例模式</a>\\n<ul>\\n<li>确保一个类只有一个实例，并提供全局访问点。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
