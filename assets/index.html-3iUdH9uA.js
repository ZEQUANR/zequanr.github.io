const e=JSON.parse('{"key":"v-2b6c5c56","path":"/Go/Heap/","title":"Heap","lang":"zh-CN","frontmatter":{"title":"Heap","icon":"material-symbols:heap-snapshot-large-outline","author":"王泽权","date":"2023-07-19T00:00:00.000Z","category":["Go"],"tag":["Go"],"sticky":true,"star":true,"copyright":"王泽权","description":"heap 是一种常见的数据结构，本周将带大家来了解一下 Go 语言标准库中的 Heap 包，首先在此之前我们需要对堆(heap) 有所概念，简单理解就是用数组实现的完全二叉树，在 Go 官方概述中有这样说道“堆是一棵树，其属性是每个节点都是其子树中的最小值节点”，那么堆的属性又是什么呢？ 所谓的“堆属性”指的就是最大堆与最小堆，这两者之间最大的区别在于数据的排列方式不同，如图 1 所示在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小，在 Go 语言中所采用的是最小堆，树中最小的元素是根，索引为 0。 通过刚刚的讲述想必我们已经对堆有了一个基础的概念，那问题来了，虽然堆在物理结构上是一个一维的数组，但在存储逻辑上是一棵完全二叉树，所以堆的数据结构是非线性的，那它即没有指针指向当前节点的父节点或子节点，也没有多余的空间用来存储当前节点信息，我们该如何对当前节点元素完成父子节点的定位操作。","head":[["meta",{"property":"og:url","content":"https://zequanr.github.io/Go/Heap/"}],["meta",{"property":"og:site_name","content":"ZEQUANR"}],["meta",{"property":"og:title","content":"Heap"}],["meta",{"property":"og:description","content":"heap 是一种常见的数据结构，本周将带大家来了解一下 Go 语言标准库中的 Heap 包，首先在此之前我们需要对堆(heap) 有所概念，简单理解就是用数组实现的完全二叉树，在 Go 官方概述中有这样说道“堆是一棵树，其属性是每个节点都是其子树中的最小值节点”，那么堆的属性又是什么呢？ 所谓的“堆属性”指的就是最大堆与最小堆，这两者之间最大的区别在于数据的排列方式不同，如图 1 所示在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小，在 Go 语言中所采用的是最小堆，树中最小的元素是根，索引为 0。 通过刚刚的讲述想必我们已经对堆有了一个基础的概念，那问题来了，虽然堆在物理结构上是一个一维的数组，但在存储逻辑上是一棵完全二叉树，所以堆的数据结构是非线性的，那它即没有指针指向当前节点的父节点或子节点，也没有多余的空间用来存储当前节点信息，我们该如何对当前节点元素完成父子节点的定位操作。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://zequanr.github.io/"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-25T09:54:30.000Z"}],["meta",{"name":"twitter:card","content":"summary_large_image"}],["meta",{"name":"twitter:image:alt","content":"Heap"}],["meta",{"property":"article:author","content":"王泽权"}],["meta",{"property":"article:tag","content":"Go"}],["meta",{"property":"article:published_time","content":"2023-07-19T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2024-01-25T09:54:30.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Heap\\",\\"image\\":[\\"https://zequanr.github.io/\\"],\\"datePublished\\":\\"2023-07-19T00:00:00.000Z\\",\\"dateModified\\":\\"2024-01-25T09:54:30.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"王泽权\\"}]}"]]},"headers":[],"git":{"createdTime":1706176470000,"updatedTime":1706176470000,"contributors":[{"name":"ZEQUANR","email":"675897584@qq.com","commits":1}]},"readingTime":{"minutes":9.73,"words":2918},"filePathRelative":"Go/Heap/README.md","localizedDate":"2023年7月19日","excerpt":"<p>heap 是一种常见的数据结构，本周将带大家来了解一下 Go 语言标准库中的 Heap 包，首先在此之前我们需要对堆(heap) 有所概念，简单理解就是用数组实现的完全二叉树，在 Go 官方概述中有这样说道“堆是一棵树，其属性是每个节点都是其子树中的最小值节点”，那么堆的属性又是什么呢？</p>\\n<p>所谓的“堆属性”指的就是最大堆与最小堆，这两者之间最大的区别在于数据的排列方式不同，如图 1 所示在最大堆中，父节点的值比每一个子节点的值都要大。在最小堆中，父节点的值比每一个子节点的值都要小，在 Go 语言中所采用的是最小堆，树中最小的元素是根，索引为 0。\\n</p>\\n<br>\\n<p>通过刚刚的讲述想必我们已经对堆有了一个基础的概念，那问题来了，虽然堆在物理结构上是一个一维的数组，但在存储逻辑上是一棵完全二叉树，所以堆的数据结构是非线性的，那它即没有指针指向当前节点的父节点或子节点，也没有多余的空间用来存储当前节点信息，我们该如何对当前节点元素完成父子节点的定位操作。</p>","autoDesc":true}');export{e as data};
