const t=JSON.parse('{"key":"v-427af5f4","path":"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/","title":"创建型设计模式","lang":"zh-CN","frontmatter":{"title":"创建型设计模式","icon":"uil:create-dashboard","article":false,"description":"行为型设计模式 策略模式 定义了一系列算法，并将每个算法封装起来，让它们可以互相替换。 模板方法模式 在一个抽象类中定义一个操作中的框架，而将一些步骤延迟到子类中实现。 观察者模式 多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。 发布-订阅模式 也称为事件驱动模式，它解耦了事件的生产者和消费者，通常通过事件中心或者消息队列来处理异步通信。 状态模式 允许一个对象在其内部状态改变时改变其行为。 迭代器模式 提供一种方法顺序访问聚合对象的元素，而又不暴露其底层表示。 责任链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 命令模式 将一个请求封装为一个对象，从而使用户能够参数化其他对象的方法调用、排队或记录请求。","head":[["meta",{"property":"og:url","content":"https://zequanr.github.io/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/"}],["meta",{"property":"og:site_name","content":"ZEQUANR"}],["meta",{"property":"og:title","content":"创建型设计模式"}],["meta",{"property":"og:description","content":"行为型设计模式 策略模式 定义了一系列算法，并将每个算法封装起来，让它们可以互相替换。 模板方法模式 在一个抽象类中定义一个操作中的框架，而将一些步骤延迟到子类中实现。 观察者模式 多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。 发布-订阅模式 也称为事件驱动模式，它解耦了事件的生产者和消费者，通常通过事件中心或者消息队列来处理异步通信。 状态模式 允许一个对象在其内部状态改变时改变其行为。 迭代器模式 提供一种方法顺序访问聚合对象的元素，而又不暴露其底层表示。 责任链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 命令模式 将一个请求封装为一个对象，从而使用户能够参数化其他对象的方法调用、排队或记录请求。"}],["meta",{"property":"og:type","content":"website"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-01-24T08:24:26.000Z"}],["meta",{"property":"article:author","content":"ZEQUANR"}],["meta",{"property":"article:modified_time","content":"2024-01-24T08:24:26.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"WebPage\\",\\"name\\":\\"创建型设计模式\\",\\"description\\":\\"行为型设计模式 策略模式 定义了一系列算法，并将每个算法封装起来，让它们可以互相替换。 模板方法模式 在一个抽象类中定义一个操作中的框架，而将一些步骤延迟到子类中实现。 观察者模式 多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。 发布-订阅模式 也称为事件驱动模式，它解耦了事件的生产者和消费者，通常通过事件中心或者消息队列来处理异步通信。 状态模式 允许一个对象在其内部状态改变时改变其行为。 迭代器模式 提供一种方法顺序访问聚合对象的元素，而又不暴露其底层表示。 责任链模式 使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。 命令模式 将一个请求封装为一个对象，从而使用户能够参数化其他对象的方法调用、排队或记录请求。\\"}"]]},"headers":[{"level":3,"title":"行为型设计模式","slug":"行为型设计模式","link":"#行为型设计模式","children":[]}],"git":{"createdTime":1706084666000,"updatedTime":1706084666000,"contributors":[{"name":"ZEQUANR","email":"675897584@qq.com","commits":1}]},"readingTime":{"minutes":1.12,"words":337},"filePathRelative":"FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/README.md","localizedDate":"2024年1月24日","excerpt":"<h3> 行为型设计模式</h3>\\n<ul>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/StrategyPattern\\">策略模式</a>\\n<ul>\\n<li>定义了一系列算法，并将每个算法封装起来，让它们可以互相替换。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/TemplateMethodPattern\\">模板方法模式</a>\\n<ul>\\n<li>在一个抽象类中定义一个操作中的框架，而将一些步骤延迟到子类中实现。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/ObserverPattern\\">观察者模式</a>\\n<ul>\\n<li>多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/PublishSubscribePattern\\">发布-订阅模式</a>\\n<ul>\\n<li>也称为事件驱动模式，它解耦了事件的生产者和消费者，通常通过事件中心或者消息队列来处理异步通信。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/StatePattern\\">状态模式</a>\\n<ul>\\n<li>允许一个对象在其内部状态改变时改变其行为。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/IteratorPattern\\">迭代器模式</a>\\n<ul>\\n<li>提供一种方法顺序访问聚合对象的元素，而又不暴露其底层表示。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/ChainOfResponsibilityPattern\\">责任链模式</a>\\n<ul>\\n<li>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。</li>\\n</ul>\\n</li>\\n<li><a href=\\"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/CommandPattern\\">命令模式</a>\\n<ul>\\n<li>将一个请求封装为一个对象，从而使用户能够参数化其他对象的方法调用、排队或记录请求。</li>\\n</ul>\\n</li>\\n</ul>","autoDesc":true}');export{t as data};
