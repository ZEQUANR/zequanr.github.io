import{_ as a,o as t,c as e,a as r}from"./app-a3Zgm-oK.js";const i={},l=r('<h3 id="行为型设计模式" tabindex="-1"><a class="header-anchor" href="#行为型设计模式" aria-hidden="true">#</a> 行为型设计模式</h3><ul><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/StrategyPattern">策略模式</a><ul><li>定义了一系列算法，并将每个算法封装起来，让它们可以互相替换。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/TemplateMethodPattern">模板方法模式</a><ul><li>在一个抽象类中定义一个操作中的框架，而将一些步骤延迟到子类中实现。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/ObserverPattern">观察者模式</a><ul><li>多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/PublishSubscribePattern">发布-订阅模式</a><ul><li>也称为事件驱动模式，它解耦了事件的生产者和消费者，通常通过事件中心或者消息队列来处理异步通信。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/StatePattern">状态模式</a><ul><li>允许一个对象在其内部状态改变时改变其行为。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/IteratorPattern">迭代器模式</a><ul><li>提供一种方法顺序访问聚合对象的元素，而又不暴露其底层表示。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/ChainOfResponsibilityPattern">责任链模式</a><ul><li>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/CommandPattern">命令模式</a><ul><li>将一个请求封装为一个对象，从而使用户能够参数化其他对象的方法调用、排队或记录请求。</li></ul></li></ul>',2),n=[l];function o(s,h){return t(),e("div",null,n)}const u=a(i,[["render",o],["__file","index.html.vue"]]);export{u as default};
