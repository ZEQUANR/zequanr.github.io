import{_ as l,r as o,o as s,c as u,b as t,e as a,d as e,w as n,a as i}from"./app-WYeiPlGe.js";const c={},P=t("p",null,"JavaScript 中的设计模式种类丰富，它们根据功能和目的的不同，可以被分为三大类：",-1),d={id:"创建型设计模式",tabindex:"-1"},h=t("a",{class:"header-anchor",href:"#创建型设计模式","aria-hidden":"true"},"#",-1),v=i('<ul><li><a href="/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/ConstructorPattern">构造函数模式</a><ul><li>通过定义一个构造函数来初始化新对象的属性，并通过new关键字调用构造函数创建实例。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/PrototypePattern">原型模式</a><ul><li>通过复制现有对象来创建新对象，而不是每次都新建一个全新的实例。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/FactoryPattern">工厂模式</a><ul><li>提供一个接口用于创建一系列相关或依赖对象，而无需指定具体的类。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/AbstractFactoryPattern">抽象工厂模式</a><ul><li>提供一个接口，用于创建相关或依赖对象家族的工厂，而无需指定具体的产品类。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/BuilderPattern">建造者模式</a><ul><li>将复杂的构建过程与表示分离，使得相同的构建过程可以创建不同的表示。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/SingletonPattern">单例模式</a><ul><li>确保一个类只有一个实例，并提供全局访问点。</li></ul></li></ul>',1),_={id:"结构型设计模式",tabindex:"-1"},p=t("a",{class:"header-anchor",href:"#结构型设计模式","aria-hidden":"true"},"#",-1),S=i('<ul><li><a href="/FrontEnd/JavaScript/DesignPattern/StructuralPatterns/AdapterPattern">适配器模式</a><ul><li>将一个类的接口转换成客户希望的另一个接口。使得原本由于接口不兼容而不能一起工作的类能够协同工作。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/StructuralPatterns/DecoratorPattern">装饰器模式</a><ul><li>在运行时动态地向对象添加新的行为，同时保持类的单一职责原则。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/StructuralPatterns/ProxyPattern">代理模式</a><ul><li>为其他对象提供一种代理以控制对这个对象的访问。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/StructuralPatterns/FacadePattern">外观模式</a><ul><li>提供了一个统一的接口，用来访问子系统中的一群接口。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/StructuralPatterns/BridgePattern">桥接模式</a><ul><li>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/StructuralPatterns/CompositePattern">组合模式</a><ul><li>允许你将对象组合成树形结构来表现“整体-部分”的层次结构。</li></ul></li></ul>',1),f={id:"行为型设计模式",tabindex:"-1"},g=t("a",{class:"header-anchor",href:"#行为型设计模式","aria-hidden":"true"},"#",-1),F=i('<ul><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/StrategyPattern">策略模式</a><ul><li>定义了一系列算法，并将每个算法封装起来，让它们可以互相替换。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/TemplateMethodPattern">模板方法模式</a><ul><li>在一个抽象类中定义一个操作中的框架，而将一些步骤延迟到子类中实现。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/ObserverPattern">观察者模式</a><ul><li>多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/PublishSubscribePattern">发布-订阅模式</a><ul><li>也称为事件驱动模式，它解耦了事件的生产者和消费者，通常通过事件中心或者消息队列来处理异步通信。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/StatePattern">状态模式</a><ul><li>允许一个对象在其内部状态改变时改变其行为。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/IteratorPattern">迭代器模式</a><ul><li>提供一种方法顺序访问聚合对象的元素，而又不暴露其底层表示。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/ChainOfResponsibilityPattern">责任链模式</a><ul><li>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。</li></ul></li><li><a href="/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/CommandPattern">命令模式</a><ul><li>将一个请求封装为一个对象，从而使用户能够参数化其他对象的方法调用、排队或记录请求。</li></ul></li></ul>',1);function D(E,J){const r=o("RouterLink");return s(),u("div",null,[P,t("h3",d,[h,a(),e(r,{to:"/FrontEnd/JavaScript/DesignPattern/CreationalPatterns/"},{default:n(()=>[a("创建型设计模式")]),_:1})]),v,t("h3",_,[p,a(),e(r,{to:"/FrontEnd/JavaScript/DesignPattern/StructuralPatterns/"},{default:n(()=>[a("结构型设计模式")]),_:1})]),S,t("h3",f,[g,a(),e(r,{to:"/FrontEnd/JavaScript/DesignPattern/BehavioralPatterns/"},{default:n(()=>[a("行为型设计模式")]),_:1})]),F])}const C=l(c,[["render",D],["__file","index.html.vue"]]);export{C as default};
